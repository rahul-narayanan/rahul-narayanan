import { Component, Input, OnInit } from '@angular/core';
import { FormControl, FormGroupDirective, NgForm } from '@angular/forms';
import { ErrorStateMatcher } from '@angular/material/core';

@Component({
  selector: 'app-input',
  template: `
    <mat-form-field>
      <input matInput [formControl]="formControl" [formControlName]="formControlName" [type]="type" [placeholder]="placeholder">
      <mat-error *ngIf="controlInvalid">
        <div *ngIf="formControl.errors?.required">
          {{requiredErrorMessage}}
        </div>
        <div *ngIf="formControl.errors?.pattern">
          {{patternErrorMessage}}
        </div>
        <!-- Add additional error messages for other validation rules -->
      </mat-error>
    </mat-form-field>
  `,
})
export class InputComponent implements OnInit {
  @Input() formControl: FormControl;
  @Input() formControlName: string;
  @Input() type = 'text';
  @Input() placeholder = '';

  @Input() requiredErrorMessage = 'This field is required.';
  @Input() patternErrorMessage = 'Invalid input.';

  // Add additional error message inputs for other validation rules

  controlInvalid = false;
  matcher: ErrorStateMatcher;

  constructor(private formGroupDirective: FormGroupDirective) {
    this.matcher = new MyErrorStateMatcher();
  }

  ngOnInit() {
    if (!this.formControl && this.formControlName) {
      this.formControl = this.formGroupDirective.form.get(this.formControlName) as FormControl;
    }
  }
}

class MyErrorStateMatcher implements ErrorStateMatcher {
  isErrorState(control: FormControl | null, form: FormGroupDirective | NgForm | null): boolean {
    const isSubmitted = form && form.submitted;
    const isInvalid = !!(control && control.invalid && control.parent.dirty);
    const isTouched = !!(control && control.touched);

    return (isInvalid && (isSubmitted || isTouched));
  }
}




const usersWithEntitlements = await getRepository(User)
  .createQueryBuilder('user')
  .select(['user.id', 'user.name', 'JSON_ARRAYAGG(JSON_OBJECT("entitlement_type", entitlement.type, "entitlement_value", entitlement.value)) AS entitlements'])
  .leftJoin('user.entitlements', 'entitlement')
  .groupBy('user.id')
  .getRawMany();
  
  
  
  
  
  
  
  
  const usersWithEntitlements = await getRepository(User)
  .createQueryBuilder('user')
  .select(['user.id', 'user.name', `CONCAT('[', STRING_AGG(CONCAT('{"entitlement_type":"', entitlement.type, '", "entitlement_value":"', entitlement.value, '"}'), ','), ']') AS entitlements`])
  .leftJoin('user.entitlements', 'entitlement')
  .groupBy('user.id')
  .getRawMany();
  
  
  
  
  
  SELECT CAST((SELECT id AS [id], name AS [name] 
FROM your_table_name
FOR JSON PATH) AS NVARCHAR(MAX)) AS [json]




SELECT 
    (SELECT id AS [id], name AS [name] 
     FROM your_table_name
     FOR JSON PATH, WITHOUT_ARRAY_WRAPPER
    ) AS [json]
FOR JSON PATH, WITHOUT_ARRAY_WRAPPER




SELECT 
    JSON_QUERY(
        CONCAT('{', STRING_AGG(CONCAT('"', id, '":"', name, '"'), ','), '}')
    ) AS [json]
FROM your_table_name



SELECT 
    JSON_QUERY(
        CONCAT('{', STUFF((
            SELECT CONCAT(',"', id, '":"', name, '"')
            FROM your_table_name
            FOR XML PATH('')
        ), 1, 1, ''), '}')
    ) AS [dictionary]

