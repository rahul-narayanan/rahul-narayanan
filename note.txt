intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const httpContext = context.switchToHttp();
    const request = httpContext.getRequest();
    const response = httpContext.getResponse();

    // Generate a unique cache key based on the request URL and other factors
    const cacheKey = this.generateCacheKey(request);

    // Check if the data is already cached
    return from(this.cachingService.get<CachedData>(cacheKey)).pipe(
      mergeMap((cachedData) => {
        if (cachedData) {
          // Data is available in the cache; return it as the response
          return of(cachedData);
        }

        // Data is not in the cache; proceed with the request and cache the response
        return next.handle().pipe(
          map((data) => {
            // Cache the response data
            this.cachingService.set(cacheKey, data);
            return data;
          }),
        );
      }),
    );
  }

  private generateCacheKey(request: any): string {
    // Implement your own logic to generate a unique cache key based on the request
    // For example, you can use the request URL or request parameters
    return request.url;
  }
