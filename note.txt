import { Component, Input } from '@angular/core';
import { FormControl } from '@angular/forms';
import { MatAutocompleteSelectedEvent } from '@angular/material/autocomplete';
import { Observable } from 'rxjs';
import { map, startWith } from 'rxjs/operators';

@Component({
  selector: 'app-multiselect-autocomplete',
  templateUrl: './multiselect-autocomplete.component.html',
  styleUrls: ['./multiselect-autocomplete.component.css'],
})
export class MultiselectAutocompleteComponent {
  @Input() optionsService: any;
  @Input() displayProp: string;
  @Input() valueProp: string;
  @Input() label: string;
  @Input() placeholder: string;
  @Input() required: boolean;
  @Input() disabled: boolean;
  @Input() error: string;
  @Input() selectedOptions: any[] = [];
  @Input() maxSelectedOptions: number;

  searchControl = new FormControl();
  options: any[] = [];
  filteredOptions$: Observable<any[]>;
  loading = false;

  constructor() {}

  ngOnInit() {
    this.fetchOptions();
    this.filteredOptions$ = this.searchControl.valueChanges.pipe(
      startWith(null),
      map((searchTerm: string | null) =>
        searchTerm ? this._filterOptions(searchTerm) : this.options.slice()
      )
    );
  }

  private fetchOptions() {
    this.loading = true;
    this.optionsService.getOptions().subscribe(
      (options) => {
        this.loading = false;
        this.options = options;
      },
      (error) => {
        this.loading = false;
        console.error(error);
      }
    );
  }

  private _filterOptions(searchTerm: string): any[] {
    const filterValue = searchTerm.toLowerCase();
    return this.options.filter(
      (option) => option[this.displayProp].toLowerCase().indexOf(filterValue) > -1
    );
  }

  displayFn(option: any): string {
    return option && option[this.displayProp] ? option[this.displayProp] : '';
  }

  selectOption(event: MatAutocompleteSelectedEvent) {
    const option = event.option.value;
    if (this.maxSelectedOptions && this.selectedOptions.length >= this.maxSelectedOptions) {
      return;
    }
    if (!this.selectedOptions.some((o) => o[this.valueProp] === option[this.valueProp])) {
      this.selectedOptions.push(option);
    }
    this.searchControl.setValue(null);
  }

  removeOption(option: any) {
    const index = this.selectedOptions.indexOf(option);
    if (index >= 0) {
      this.selectedOptions.splice(index, 1);
    }
  }
}



<mat-form-field [style.width]="'100%'">
      <mat-label>{{ label }}</mat-label>
      <mat-chip-list #chipList [disabled]="disabled">
        <mat-chip *ngFor="let option of selectedOptions" [removable]="true" (removed)="removeOption(option)">
          {{ option[displayProp] }}
          <mat-icon matChipRemove>cancel</mat-icon>
        </mat-chip>
        <input
          type="text"
          placeholder="{{ placeholder }}"
          [formControl]="searchControl"
          [matAutocomplete]="auto"
          (focus)="auto.openPanel()"
          [disabled]="disabled"
        />
      </mat-chip-list>
      <mat-autocomplete #auto="matAutocomplete" [displayWith]="displayFn" (optionSelected)="selectOption($event)">
        <mat-option *ngFor="let option of filteredOptions$ | async" [value]="option">
          {{ option[displayProp] }}
        </mat-option>
      </mat-autocomplete>
      <mat-error>{{ error }}</mat-error>
      <mat-spinner *ngIf="loading" matSuffix diameter="20"></mat-spinner>
    </mat-form-field>